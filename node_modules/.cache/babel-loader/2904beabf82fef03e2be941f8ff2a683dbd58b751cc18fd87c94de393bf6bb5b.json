{"ast":null,"code":"(function (global, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory);\n  } else if (typeof module !== 'undefined' && module.exports) {\n    module.exports = factory();\n  } else {\n    global.sha256 = factory();\n  }\n})(this, function () {\n  var sha256 = function sha256(ascii) {\n    function rightRotate(value, amount) {\n      return value >>> amount | value << 32 - amount;\n    }\n    ;\n    var mathPow = Math.pow;\n    var maxWord = mathPow(2, 32);\n    var lengthProperty = 'length';\n    var i, j; // Used as a counter across the whole file\n    var result = '';\n    var words = [];\n    var asciiBitLength = ascii[lengthProperty] * 8;\n\n    //* caching results is optional - remove/add slash from front of this line to toggle\n    // Initial hash value: first 32 bits of the fractional parts of the square roots of the first 8 primes\n    // (we actually calculate the first 64, but extra values are just ignored)\n    var hash = sha256.h = sha256.h || [];\n    // Round constants: first 32 bits of the fractional parts of the cube roots of the first 64 primes\n    var k = sha256.k = sha256.k || [];\n    var primeCounter = k[lengthProperty];\n    /*/\r\n    var hash = [], k = [];\r\n    var primeCounter = 0;\r\n    //*/\n\n    var isComposite = {};\n    for (var candidate = 2; primeCounter < 64; candidate++) {\n      if (!isComposite[candidate]) {\n        for (i = 0; i < 313; i += candidate) {\n          isComposite[i] = candidate;\n        }\n        hash[primeCounter] = mathPow(candidate, .5) * maxWord | 0;\n        k[primeCounter++] = mathPow(candidate, 1 / 3) * maxWord | 0;\n      }\n    }\n    ascii += '\\x80'; // Append '1' bit (plus zero padding)\n    while (ascii[lengthProperty] % 64 - 56) ascii += '\\x00'; // More zero padding\n    for (i = 0; i < ascii[lengthProperty]; i++) {\n      j = ascii.charCodeAt(i);\n      if (j >> 8) return; // ASCII check: only accept characters in range 0-255\n      words[i >> 2] |= j << (3 - i) % 4 * 8;\n    }\n    words[words[lengthProperty]] = asciiBitLength / maxWord | 0;\n    words[words[lengthProperty]] = asciiBitLength;\n\n    // process each chunk\n    for (j = 0; j < words[lengthProperty];) {\n      var w = words.slice(j, j += 16); // The message is expanded into 64 words as part of the iteration\n      var oldHash = hash;\n      // This is now the \"working hash\", often labelled as variables a...g\n      // (we have to truncate as well, otherwise extra entries at the end accumulate\n      hash = hash.slice(0, 8);\n      for (i = 0; i < 64; i++) {\n        var i2 = i + j;\n        // Expand the message into 64 words\n        // Used below if \n        var w15 = w[i - 15],\n          w2 = w[i - 2];\n\n        // Iterate\n        var a = hash[0],\n          e = hash[4];\n        var temp1 = hash[7] + (rightRotate(e, 6) ^ rightRotate(e, 11) ^ rightRotate(e, 25)) // S1\n        + (e & hash[5] ^ ~e & hash[6]) // ch\n        + k[i]\n        // Expand the message schedule if needed\n        + (w[i] = i < 16 ? w[i] : w[i - 16] + (rightRotate(w15, 7) ^ rightRotate(w15, 18) ^ w15 >>> 3) // s0\n        + w[i - 7] + (rightRotate(w2, 17) ^ rightRotate(w2, 19) ^ w2 >>> 10) // s1\n        | 0);\n        // This is only used once, so *could* be moved below, but it only saves 4 bytes and makes things unreadble\n        var temp2 = (rightRotate(a, 2) ^ rightRotate(a, 13) ^ rightRotate(a, 22) // S0\n        ) + (a & hash[1] ^ a & hash[2] ^ hash[1] & hash[2]); // maj\n\n        hash = [temp1 + temp2 | 0].concat(hash); // We don't bother trimming off the extra ones, they're harmless as long as we're truncating when we do the slice()\n        hash[4] = hash[4] + temp1 | 0;\n      }\n      for (i = 0; i < 8; i++) {\n        hash[i] = hash[i] + oldHash[i] | 0;\n      }\n    }\n    for (i = 0; i < 8; i++) {\n      for (j = 3; j + 1; j--) {\n        var b = hash[i] >> j * 8 & 255;\n        result += (b < 16 ? 0 : '') + b.toString(16);\n      }\n    }\n    return result;\n  };\n  sha256.code = \"var sha256=function a(b){function c(a,b){return a>>>b|a<<32-b}for(var d,e,f=Math.pow,g=f(2,32),h=\\\"length\\\",i=\\\"\\\",j=[],k=8*b[h],l=a.h=a.h||[],m=a.k=a.k||[],n=m[h],o={},p=2;64>n;p++)if(!o[p]){for(d=0;313>d;d+=p)o[d]=p;l[n]=f(p,.5)*g|0,m[n++]=f(p,1/3)*g|0}for(b+=\\\"\\\\x80\\\";b[h]%64-56;)b+=\\\"\\\\x00\\\";for(d=0;d<b[h];d++){if(e=b.charCodeAt(d),e>>8)return;j[d>>2]|=e<<(3-d)%4*8}for(j[j[h]]=k/g|0,j[j[h]]=k,e=0;e<j[h];){var q=j.slice(e,e+=16),r=l;for(l=l.slice(0,8),d=0;64>d;d++){var s=q[d-15],t=q[d-2],u=l[0],v=l[4],w=l[7]+(c(v,6)^c(v,11)^c(v,25))+(v&l[5]^~v&l[6])+m[d]+(q[d]=16>d?q[d]:q[d-16]+(c(s,7)^c(s,18)^s>>>3)+q[d-7]+(c(t,17)^c(t,19)^t>>>10)|0),x=(c(u,2)^c(u,13)^c(u,22))+(u&l[1]^u&l[2]^l[1]&l[2]);l=[w+x|0].concat(l),l[4]=l[4]+w|0}for(d=0;8>d;d++)l[d]=l[d]+r[d]|0}for(d=0;8>d;d++)for(e=3;e+1;e--){var y=l[d]>>8*e&255;i+=(16>y?0:\\\"\\\")+y.toString(16)}return i};\";\n  return sha256;\n});","map":{"version":3,"names":["global","factory","define","amd","module","exports","sha256","ascii","rightRotate","value","amount","mathPow","Math","pow","maxWord","lengthProperty","i","j","result","words","asciiBitLength","hash","h","k","primeCounter","isComposite","candidate","charCodeAt","w","slice","oldHash","i2","w15","w2","a","e","temp1","temp2","concat","b","toString","code"],"sources":["/Users/navamongkoltongta/workspace/sn2/shopassistant-register/node_modules/tiny-sha256/index.js"],"sourcesContent":["(function (global, factory) {\r\n\tif (typeof define === 'function' && define.amd) {\r\n\t\tdefine([], factory);\r\n\t} else if (typeof module !== 'undefined' && module.exports){\r\n\t\tmodule.exports = factory();\r\n\t} else {\r\n\t\tglobal.sha256 = factory();\r\n\t}\r\n})(this, function () {\r\n\r\nvar sha256 = function sha256(ascii) {\r\n\tfunction rightRotate(value, amount) {\r\n\t\treturn (value>>>amount) | (value<<(32 - amount));\r\n\t};\r\n\t\r\n\tvar mathPow = Math.pow;\r\n\tvar maxWord = mathPow(2, 32);\r\n\tvar lengthProperty = 'length';\r\n\tvar i, j; // Used as a counter across the whole file\r\n\tvar result = '';\r\n\r\n\tvar words = [];\r\n\tvar asciiBitLength = ascii[lengthProperty]*8;\r\n\t\r\n\t//* caching results is optional - remove/add slash from front of this line to toggle\r\n\t// Initial hash value: first 32 bits of the fractional parts of the square roots of the first 8 primes\r\n\t// (we actually calculate the first 64, but extra values are just ignored)\r\n\tvar hash = sha256.h = sha256.h || [];\r\n\t// Round constants: first 32 bits of the fractional parts of the cube roots of the first 64 primes\r\n\tvar k = sha256.k = sha256.k || [];\r\n\tvar primeCounter = k[lengthProperty];\r\n\t/*/\r\n\tvar hash = [], k = [];\r\n\tvar primeCounter = 0;\r\n\t//*/\r\n\r\n\tvar isComposite = {};\r\n\tfor (var candidate = 2; primeCounter < 64; candidate++) {\r\n\t\tif (!isComposite[candidate]) {\r\n\t\t\tfor (i = 0; i < 313; i += candidate) {\r\n\t\t\t\tisComposite[i] = candidate;\r\n\t\t\t}\r\n\t\t\thash[primeCounter] = (mathPow(candidate, .5)*maxWord)|0;\r\n\t\t\tk[primeCounter++] = (mathPow(candidate, 1/3)*maxWord)|0;\r\n\t\t}\r\n\t}\r\n\t\r\n\tascii += '\\x80'; // Append '1' bit (plus zero padding)\r\n\twhile (ascii[lengthProperty]%64 - 56) ascii += '\\x00'; // More zero padding\r\n\tfor (i = 0; i < ascii[lengthProperty]; i++) {\r\n\t\tj = ascii.charCodeAt(i);\r\n\t\tif (j>>8) return; // ASCII check: only accept characters in range 0-255\r\n\t\twords[i>>2] |= j << ((3 - i)%4)*8;\r\n\t}\r\n\twords[words[lengthProperty]] = ((asciiBitLength/maxWord)|0);\r\n\twords[words[lengthProperty]] = (asciiBitLength)\r\n\t\r\n\t// process each chunk\r\n\tfor (j = 0; j < words[lengthProperty];) {\r\n\t\tvar w = words.slice(j, j += 16); // The message is expanded into 64 words as part of the iteration\r\n\t\tvar oldHash = hash;\r\n\t\t// This is now the \"working hash\", often labelled as variables a...g\r\n\t\t// (we have to truncate as well, otherwise extra entries at the end accumulate\r\n\t\thash = hash.slice(0, 8);\r\n\t\t\r\n\t\tfor (i = 0; i < 64; i++) {\r\n\t\t\tvar i2 = i + j;\r\n\t\t\t// Expand the message into 64 words\r\n\t\t\t// Used below if \r\n\t\t\tvar w15 = w[i - 15], w2 = w[i - 2];\r\n\r\n\t\t\t// Iterate\r\n\t\t\tvar a = hash[0], e = hash[4];\r\n\t\t\tvar temp1 = hash[7]\r\n\t\t\t\t+ (rightRotate(e, 6) ^ rightRotate(e, 11) ^ rightRotate(e, 25)) // S1\r\n\t\t\t\t+ ((e&hash[5])^((~e)&hash[6])) // ch\r\n\t\t\t\t+ k[i]\r\n\t\t\t\t// Expand the message schedule if needed\r\n\t\t\t\t+ (w[i] = (i < 16) ? w[i] : (\r\n\t\t\t\t\t\tw[i - 16]\r\n\t\t\t\t\t\t+ (rightRotate(w15, 7) ^ rightRotate(w15, 18) ^ (w15>>>3)) // s0\r\n\t\t\t\t\t\t+ w[i - 7]\r\n\t\t\t\t\t\t+ (rightRotate(w2, 17) ^ rightRotate(w2, 19) ^ (w2>>>10)) // s1\r\n\t\t\t\t\t)|0\r\n\t\t\t\t);\r\n\t\t\t// This is only used once, so *could* be moved below, but it only saves 4 bytes and makes things unreadble\r\n\t\t\tvar temp2 = (rightRotate(a, 2) ^ rightRotate(a, 13) ^ rightRotate(a, 22)) // S0\r\n\t\t\t\t+ ((a&hash[1])^(a&hash[2])^(hash[1]&hash[2])); // maj\r\n\t\t\t\r\n\t\t\thash = [(temp1 + temp2)|0].concat(hash); // We don't bother trimming off the extra ones, they're harmless as long as we're truncating when we do the slice()\r\n\t\t\thash[4] = (hash[4] + temp1)|0;\r\n\t\t}\r\n\t\t\r\n\t\tfor (i = 0; i < 8; i++) {\r\n\t\t\thash[i] = (hash[i] + oldHash[i])|0;\r\n\t\t}\r\n\t}\r\n\t\r\n\tfor (i = 0; i < 8; i++) {\r\n\t\tfor (j = 3; j + 1; j--) {\r\n\t\t\tvar b = (hash[i]>>(j*8))&255;\r\n\t\t\tresult += ((b < 16) ? 0 : '') + b.toString(16);\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n};\r\n\r\n\r\nsha256.code = \"var sha256=function a(b){function c(a,b){return a>>>b|a<<32-b}for(var d,e,f=Math.pow,g=f(2,32),h=\\\"length\\\",i=\\\"\\\",j=[],k=8*b[h],l=a.h=a.h||[],m=a.k=a.k||[],n=m[h],o={},p=2;64>n;p++)if(!o[p]){for(d=0;313>d;d+=p)o[d]=p;l[n]=f(p,.5)*g|0,m[n++]=f(p,1/3)*g|0}for(b+=\\\"\\\\x80\\\";b[h]%64-56;)b+=\\\"\\\\x00\\\";for(d=0;d<b[h];d++){if(e=b.charCodeAt(d),e>>8)return;j[d>>2]|=e<<(3-d)%4*8}for(j[j[h]]=k/g|0,j[j[h]]=k,e=0;e<j[h];){var q=j.slice(e,e+=16),r=l;for(l=l.slice(0,8),d=0;64>d;d++){var s=q[d-15],t=q[d-2],u=l[0],v=l[4],w=l[7]+(c(v,6)^c(v,11)^c(v,25))+(v&l[5]^~v&l[6])+m[d]+(q[d]=16>d?q[d]:q[d-16]+(c(s,7)^c(s,18)^s>>>3)+q[d-7]+(c(t,17)^c(t,19)^t>>>10)|0),x=(c(u,2)^c(u,13)^c(u,22))+(u&l[1]^u&l[2]^l[1]&l[2]);l=[w+x|0].concat(l),l[4]=l[4]+w|0}for(d=0;8>d;d++)l[d]=l[d]+r[d]|0}for(d=0;8>d;d++)for(e=3;e+1;e--){var y=l[d]>>8*e&255;i+=(16>y?0:\\\"\\\")+y.toString(16)}return i};\";\r\n\r\nreturn sha256;\r\n\r\n});"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}